"""Log related helpers for API routes."""

from __future__ import annotations

import json
from collections import deque
from pathlib import Path
from typing import Any, Dict, List, Optional

from .trade_service import get_trade_logger, record_to_trade


SYSTEM_LOG_PATH = Path("logs/api.log")


def _read_tail(path: Path, limit: int) -> List[str]:
    """Read the last N lines from a text file."""
    if limit <= 0 or not path.exists():
        return []
    
    buffer = deque(maxlen=limit)
    try:
        with open(path, "r", encoding="utf-8") as fh:
            for line in fh:
                buffer.append(line.rstrip("\n"))
    except FileNotFoundError:
        return []
    
    return list(buffer)


def _parse_system_line(line: str) -> Optional[Dict[str, Any]]:
    """Parse a log line generated by logging module."""
    if not line.strip():
        return None
    
    parts = line.split(" - ", 3)
    if len(parts) < 4:
        return None
    
    timestamp, logger_name, level, message = parts
    return {
        "timestamp": timestamp,
        "level": level.upper(),
        "type": "system",
        "message": message,
        "details": {"logger": logger_name}
    }


def get_system_logs(limit: int, level: Optional[str] = None) -> List[Dict[str, Any]]:
    """Fetch structured system logs from api.log."""
    lines = _read_tail(SYSTEM_LOG_PATH, limit * 4 if level else limit)
    level_filter = level.upper() if level else None
    
    entries: List[Dict[str, Any]] = []
    for line in reversed(lines):
        parsed = _parse_system_line(line)
        if not parsed:
            continue
        if level_filter and parsed["level"] != level_filter:
            continue
        entries.append(parsed)
        if len(entries) >= limit:
            break
    
    return entries


def get_trade_logs(limit: int, account: Optional[str] = None) -> List[Dict[str, Any]]:
    """Fetch trade log entries from the trade logger."""
    logger = get_trade_logger()
    account_filter = account.lower() if account else None
    records = logger.get_recent_trades(count=limit * 4 if account else limit)
    entries: List[Dict[str, Any]] = []
    
    for record in records:
        record_account = (record.get("follower_name") or "master").lower() if record.get("type") != "master" else "master"
        if account_filter and record_account != account_filter:
            continue
        
        trade_summary = record_to_trade(record)
        level = "ERROR" if record.get("error") else "INFO"
        message = f"{trade_summary['account']} {trade_summary['side']} {trade_summary['symbol']} x{trade_summary['quantity']} @ {trade_summary['price']}"
        if record.get("status"):
            message += f" [{record.get('status')}]"
        
        entries.append({
            "timestamp": trade_summary["timestamp"],
            "level": level,
            "type": "trade",
            "message": message,
            "details": trade_summary
        })
        
        if len(entries) >= limit:
            break
    
    return entries


def get_error_logs(limit: int) -> List[Dict[str, Any]]:
    """Fetch error entries from trade logger and system logs."""
    logger = get_trade_logger()
    error_records = logger.get_records_by_type("error", limit=limit)
    entries: List[Dict[str, Any]] = []
    
    for record in error_records:
        entries.append({
            "timestamp": record.get("timestamp"),
            "level": "ERROR",
            "type": "error",
            "message": record.get("error_message"),
            "details": {
                "follower": record.get("follower_name"),
                "symbol": record.get("symbol"),
                "error_type": record.get("error_type"),
                "context": record.get("context")
            }
        })
    
    # Supplement with system ERROR logs if we still need more entries
    if len(entries) < limit:
        remaining = limit - len(entries)
        system_errors = [
            entry for entry in get_system_logs(remaining * 4, level="ERROR")
        ]
        entries.extend(system_errors[:remaining])
    
    entries.sort(key=lambda item: item.get("timestamp", ""), reverse=True)
    return entries[:limit]


def _truncate_file(path: Path) -> None:
    """Truncate file safely."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8"):
        # Opening in write mode truncates the file.
        pass


def _remove_trade_errors() -> int:
    """Remove error records from trade log file."""
    logger = get_trade_logger()
    log_path = logger.log_file
    if not log_path.exists():
        return 0
    
    removed = 0
    with logger.lock:
        with open(log_path, "r", encoding="utf-8") as fh:
            lines = fh.readlines()
        
        kept_lines: List[str] = []
        for line in lines:
            try:
                record = json.loads(line)
            except json.JSONDecodeError:
                kept_lines.append(line)
                continue
            
            if record.get("type") == "error":
                removed += 1
                continue
            kept_lines.append(line)
        
        with open(log_path, "w", encoding="utf-8") as fh:
            fh.writelines(kept_lines)
    
    return removed


def clear_logs(log_type: str) -> Dict[str, Any]:
    """
    Clear log files based on log_type.
    
    Returns metadata about actions performed.
    """
    results = {"system_cleared": False, "trade_cleared": False, "error_removed": 0}
    
    if log_type in {"system", "all"}:
        _truncate_file(SYSTEM_LOG_PATH)
        results["system_cleared"] = True
    
    if log_type in {"trade", "all"}:
        trade_logger = get_trade_logger()
        with trade_logger.lock:
            _truncate_file(trade_logger.log_file)
        results["trade_cleared"] = True
    
    if log_type in {"error", "all"}:
        results["error_removed"] = _remove_trade_errors()
    
    return results
